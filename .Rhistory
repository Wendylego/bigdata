runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp()
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
source('~/Rapport/Traitement_Images.R')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp()
runApp('Rapport')
runApp('Rapport')
runApp()
runApp('Rapport')
runApp()
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
source('~/Rapport/Traitement_Images.R')
shiny::runApp('Rapport')
runApp('Rapport')
source('~/Rapport/Traitement_Images.R')
runApp('Rapport')
return(RES2)
source('~/Rapport/Traitement_Images.R')
shiny::runApp('Rapport')
View(Sample_Usual_Method)
View(Sample_Usual_Method)
shiny::runApp('Rapport')
install.packages('shiny')
install.packages("shiny")
install.packages("knitr")
install.packages(c("backports", "BH", "broom", "callr", "class", "cli", "clipr", "colorspace", "cowplot", "cpp11", "crayon", "crosstalk", "data.table", "DBI", "desc", "devtools", "digest", "dplyr", "DT", "e1071", "ellipsis", "fansi", "farver", "fastmap", "forcats", "generics", "ggplot2", "ggrepel", "ggsignif", "gh", "git2r", "glmnet", "grpreg", "haven", "highr", "Hmisc", "hms", "httpuv", "insight", "ipred", "isoband", "jquerylib", "jsonlite", "later", "lava", "lifecycle", "lubridate", "magrittr", "maptools", "MASS", "mathjaxr", "MatrixModels", "matrixStats", "memoise", "mgcv", "mime", "pbkrtest", "pillar", "pkgbuild", "pkgload", "pROC", "processx", "promises", "ps", "quantreg", "R6", "Rcpp", "RcppArmadillo", "RcppEigen", "recipes", "remotes", "rgl", "rio", "rJava", "robustbase", "rprojroot", "rstatix", "rstudioapi", "sp", "SparseM", "SQUAREM", "testthat", "tibble", "tidyr", "tidyselect", "tinytex", "usethis", "utf8", "vctrs", "viridis", "viridisLite", "withr", "xfun", "zoo"))
shiny::runApp('Rapport')
shiny::runApp('Rapport')
install.packages('shiny')
install.packages("shiny")
shiny::runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp()
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp()
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
rsconnect::setAccountInfo(name='wendylego',
token='F0ECEBF2A2800573612AB248D9B13E79',
secret='JjCcw/Pzt+fg52Sbdwn/w7lxvbU4+dV+jXcaGnA4')
rsconnect::deployApp("C:\Users\wendy\OneDrive\Documents\Rapport")
rsconnect::deployApp("C:/Users/wendy/OneDrive/Documents/Rapport")
runApp('Rapport')
shiny::runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
shiny::runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
runApp('Rapport')
rsconnect::setAccountInfo(name='wendylego',
token='F0ECEBF2A2800573612AB248D9B13E79',
secret='JjCcw/Pzt+fg52Sbdwn/w7lxvbU4+dV+jXcaGnA4')
rsconnect::deployApp("C:/Users/wendy/OneDrive/Documents/M1 ESA/Semestre 2/Projet_Wendy_LEGO/Shiny")
R.version.string
install.packages("asaur")
install.packages("survival")
install.packages("muhaz")
install.packages("stats")
install.packages("forestplot")
install.packages("penalized")
library(muhaz)
library(asaur)
library(survival)
library(stats)
library(forestplot)
library(penalized)
install.packages("survival")
install.packages("stats")
install.packages("survival")
install.packages("stats")
hepatoCellularNoMissing <- hepatoCellular[complete.cases(hepatoCellular),]
summary(hepatoCellularNoMissing)
attach(hepatoCellularNoMissing)
hepatoCellularNoMissing <- hepatoCellular[complete.cases(hepatoCellular),]
library(muhaz)
library(asaur)
library(survival)
library(stats)
library(forestplot)
library(penalized)
shiny::runApp('M2 ESA/rrr/ANcien projet thomas')
update.packages("Rcpp")
install.packages("Rcpp")
npest=npplregbw(lwage~as.factor(female)+as.factor(married)+educ+ tenure|exper,data=wage1)
library(gam)
attach(wage1)
?gam  #### in package gam
madd= gam(lwage~s(educ)+s(exper)+s(tenure))
summary(madd)
par(mfrow=c(2,2))
plot(madd,se=T)
dev.off()
#Avec les fonction de liens estimÃ©es par gam,
#on peut correctement spÃ©cifier un modÃ¨le paramÃ©trique:
#Modele de Mincer
regols =lm(lwage~as.factor(female)+ as.factor(married)+ educ+ tenure+ exper+ I(exper^2),data=wage1)
summary(regols)
###### Modele Semi-parametrique partiellement lineaire:
###### On suppose que le lien entre le salaire et l'experience est inconnu $m(exp)$
###### Modele : lnw = Xbeta + m(exp) + epsilon ou
###X=(female, married, edu, tenure)
### Premiere etape: Estimation de la composante non parametrique : E(lnw|exper)  et  E(X|exper)
?npplregbw
npest=npplregbw(lwage~as.factor(female)+as.factor(married)+educ+ tenure|exper,data=wage1)
###### Modele Semi-parametrique partiellement lineaire:
###### On suppose que le lien entre le salaire et l'experience est inconnu $m(exp)$
###### Modele : lnw = Xbeta + m(exp) + epsilon ou
###X=(female, married, edu, tenure)
### Premiere etape: Estimation de la composante non parametrique : E(lnw|exper)  et  E(X|exper)
?npplregbw
summary(mpl)
mpl = npplreg(npest)
library(gam)
attach(wage1)
?gam  #### in package gam
madd= gam(lwage~s(educ)+s(exper)+s(tenure))
summary(madd)
par(mfrow=c(2,2))
plot(madd,se=T)
dev.off()
#Avec les fonction de liens estimÃ©es par gam,
#on peut correctement spÃ©cifier un modÃ¨le paramÃ©trique:
#Modele de Mincer
regols =lm(lwage~as.factor(female)+ as.factor(married)+ educ+ tenure+ exper+ I(exper^2),data=wage1)
summary(regols)
###### Modele Semi-parametrique partiellement lineaire:
###### On suppose que le lien entre le salaire et l'experience est inconnu $m(exp)$
###### Modele : lnw = Xbeta + m(exp) + epsilon ou
###X=(female, married, edu, tenure)
### Premiere etape: Estimation de la composante non parametrique : E(lnw|exper)  et  E(X|exper)
?npplregbw
npest=npplregbw(lwage~as.factor(female)+as.factor(married)+educ+ tenure|exper,data=wage1)
### Deuxieme etape : Estimation du modele partiellement lineaire
?npplreg
mpl = npplreg(npest)
summary(mpl)
install.packages("tidyverse")
install.packages("wooldridge")
install.packages("KernSmooth")
install.packages("np")
install.packages("gam")
### Limites de l'approche parametrique :cout d'une mauvaise specification du modele
##Donnees diamonds contenant le prix ainsi que certaines caractÃ©ristiques de 54000 diamants
## Ces donnees sont disponibles dans ggplots.
library(ggplot2)
help(diamonds)
data("diamonds")
help(diamonds)
summary(diamonds)
attach(diamonds)
### Mauvaise spÃ©cification d'une densitÃ© paramÃ©trique issue d'une loi normale
hist(price, probability=TRUE)
x=seq(0,20000, 10)
lines(x,dnorm(x,mean(price),sd(price)), col="red")
### Mauvaise specification d'un modele de regression par un modele lineaire simple
help(economics)
tc=ggplot(economics, aes(x=date, y=unemploy/pop)) + geom_line()
+ ggtitle("Evolution du taux de chomage aux US entre 1970--2015")+ ylab("taux de chomage")
tc
### Vraie fonction de lien
tc+ geom_smooth(method="lm")
### Estimation de la fonction de lien
##### MÃ©thode d'estimation non-parametrique
# 1- Estimation par histogramme (variable d'interet le prix des diamants)
d=ggplot(data=diamonds, aes(x=price))
titre= labs("Histogramme du prix de diamants",x="prix", y="effectif")
d + geom_histogram(col="black") +titre
d + geom_histogram(binwidth=10,col="black") +titre
d + geom_histogram(binwidth=300,col="black") + titre
d + geom_histogram(binwidth=1000,col="black")  +titre
d + geom_histogram(binwidth=1000,col="black")+ xlim(c(5000,20000)) +titre
#### Remarque: L'histogramme n'est pas lisse et est sensible au choix du point d'origine,
#### de la taille de la fenetre.
help(density)
### Kernel density estimation
# Estimation par noyau en modifiant les noyaux pour un mÃªme paramÃ¨tre de lissage
d=ggplot(data=diamonds, aes(x=price))
dnr=d + geom_density(kernel= "gaussian", colour= "black")
dnr
dnre=dnr+ geom_density(kernel="epanechnikov", colour= "yellow")
dnre
dnreb=dnre + geom_density(kernel="biweight", colour= "red")
dnreb
#### RÃ©sultat:L'estimateur kernel n'est pas sensible au choix du noyau
#### Estimation par noyau en modifiant les parametres de lissage pour un noyau Gaussien
dn=d + geom_density(colour= "black")
dn
dnopt=dn+ geom_density(bw = 332.4)
dnopt     ### hopt
dnopt1= dnopt+ geom_density(bw = 100, col ="red")
dnopt1   ### sous-lissage
dnopt12= dnopt1+ geom_density(bw = 700, col ="green")
dnopt12  ### sur-lissage
#### Remarque :L'estimateur kernel est trÃ¨s sensible au choix du paramÃ¨tre de lissage
### Meilleur choix du paramÃ¨tre de lissage par la mÃ©thode visuelle
plot(density(price)) ### pour recupÃ©rer le hopt =332.4
dh=d + geom_histogram(aes(y=..density..), colour="black", fill="white")
dh
dhd=dh+ geom_density(col = 2)
dhd ### avec hopt
dhdv=dhd+geom_density(bw=250, col ="blue")
dhdv
dhdv+ geom_density(bw=300, col ="green") + geom_density(bw=225, col ="grey")
##### On estime plusieurs fois le modele en faisant varier le parametre autour du parametre optimal
###### le meilleur estimateur est celui en bleu avec hopt=250
####### Modele de regression non-parametrique
### Nadarya Watson
library(KernSmooth)
?ksmooth() #### Vous pouvez faire tourner l'exemple sur les donnees cars
##### Pour expliquer y en fonction de x,
#### on estime la fonction de lien E(y|x)
######### Simulation de donnees: n=1000
x= rnorm(1000)
y= sin(x) + rnorm(1000, 0, 0.2)
NW= ksmooth(x, y, kernel = "normal")
plot(x,y, main = "Estimateur NW de la fonction de lien")
lines(NW, lwd = 2, col = 2)
##### PolynÃ´mes locaux
?loess
lo=ggplot(economics, aes(date, uempmed)) + geom_point()
lo+ geom_smooth(col="red")  ### span= 0.75
lo50= lo+ geom_smooth(span=0.5, col="red")
lo50
lo10= lo50+ geom_smooth(span=0.10, col="green")
lo10
lo25=lo10 + geom_smooth(span=0.25, col="darkred")
lo25
########Resultat: Estimation de la fonction de lien par un polynome local de degre 2 et un bandwidth=0.10
## Modele Semi-parametrique partiellement lineaire
library(wooldridge)
library(np)
?wage1
data(wage1)
attach(wage1)
head(wage1)
####### Modeles additifs : hypothese des separabiltÃ© additive :m(educ+exper+tenure)=s(educ)+ s(expr)+s(tenure)
library(gam)
attach(wage1)
?gam  #### in package gam
madd= gam(lwage~s(educ)+s(exper)+s(tenure))
summary(madd)
par(mfrow=c(2,2))
plot(madd,se=T)
dev.off()
#Avec les fonction de liens estimÃ©es par gam,
#on peut correctement spÃ©cifier un modÃ¨le paramÃ©trique:
#Modele de Mincer
regols =lm(lwage~as.factor(female)+ as.factor(married)+ educ+ tenure+ exper+ I(exper^2),data=wage1)
summary(regols)
###### Modele Semi-parametrique partiellement lineaire:
###### On suppose que le lien entre le salaire et l'experience est inconnu $m(exp)$
###### Modele : lnw = Xbeta + m(exp) + epsilon ou
###X=(female, married, edu, tenure)
### Premiere etape: Estimation de la composante non parametrique : E(lnw|exper)  et  E(X|exper)
?npplregbw
npest=npplregbw(lwage~as.factor(female)+as.factor(married)+educ+ tenure|exper,data=wage1)
### Deuxieme etape : Estimation du modele partiellement lineaire
?npplreg
mpl = npplreg(npest)
install.packages("gam")
##### Comparaison des resultats avec ceux obtenus par le modele parametrique
summary(npest)
mpl
summary(regols)
shiny::runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
shiny::runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/lol')
runApp()
runApp()
runApp('M2 ESA/lol')
runApp()
runApp()
runApp('M2 ESA/lol')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp()
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
runApp()
runApp()
runApp('M2 ESA/bigdata_Analytics/Projet/dossierBigDataAnalytics/dossierBigDataAnalytics/test')
shiny::runApp('Big_Data_Doryane-20220123T131238Z-001/Big_Data_Doryane')
runApp('Big_Data_Doryane-20220123T131238Z-001/Big_Data_Doryane')
runApp('Big_Data_Doryane-20220123T131238Z-001/Big_Data_Doryane')
shiny::runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp()
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('Big_Data_Doryane-20220123T131238Z-001/Big_Data_Doryane')
runApp('~/AUJ-20220124T184905Z-001/AUJ')
shiny::runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp()
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp()
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp()
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
shiny::runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
runApp('AUJ-20220124T184905Z-001/AUJ')
shiny::runApp()
require(rsconnect)
rsconnect::setAccountInfo(name='wendylego',
token='F0ECEBF2A2800573612AB248D9B13E79',
secret='JjCcw/Pzt+fg52Sbdwn/w7lxvbU4+dV+jXcaGnA4')
deployApp("C:/Users/wendy/Downloads/AUJ-20220125T104156Z-001/AUJ")
require(rsconnect)
rsconnect::setAccountInfo(name='wendylego',
token='F0ECEBF2A2800573612AB248D9B13E79',
secret='JjCcw/Pzt+fg52Sbdwn/w7lxvbU4+dV+jXcaGnA4')
deployApp("C:/Users/wendy/Downloads/AUJ-20220125T104156Z-001/AUJ")
